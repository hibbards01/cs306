<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Inquisitiveness</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2015/10/12 08:32:06"/>
<meta name="author" content="Rick Neff"/>
<style type="text/css">
  html {
	font-family: Times, serif;
	font-size: 12pt;
  }
  .title { text-align: center; }
  .todo  { color: red; }
  .done { color: green; }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  .tag { background-color:lightblue; font-weight:normal }
  .target { background-color: lavender; }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
  }
  table { border-collapse: collapse; }
  td, th {
	vertical-align: top;
	<!--border: 1pt solid #ADB9CC;-->
  }
</style>
</head><body>
<h1 class="title">Inquisitiveness</h1>

<h2>EN10</h2>


<p>
You are invited to inquisitively evaluate algorithm efficiency using
Big-Oh <b>and</b> empirical measurements. This invitation to exploration
is codenamed <i>Inquisitiveness</i>.
</p>

<h3>Background</h3>


<ul>
<li>
<i>Empirical</i> means based on experimental data, not on a theory.
</li>
<li>
It means originating in or based upon observation or experience;
capable of being verified or disproved by observation or
experiment;
</li>
<li>
It is derived from observation, experience or experiment rather
than from conjecture, hypothesis or theory.

</li>
</ul>So, empirical information is based on perception with the five
senses rather than thinking and rationalism. In other words, it is
based on <i>practical</i> experience. It is often called <i>benchmarking</i>.


<h4>General Plan for Empirical Experimentation</h4>


<ol>
<li>
Understand the experiment's purpose.
</li>
<li>
Decide on the efficiency metric *M* to be measured and the
measurement unit (an operation's count or a time unit).
</li>
<li>
Decide on characteristics of the input sample (its range,
size, and so on).
</li>
<li>
Prepare a program implementing the algorithm (or
algorithms) for the experimentation.
</li>
<li>
Generate a sample of inputs.
</li>
<li>
Run the algorithm (or algorithms) on the sample's inputs
and record the data observed.
</li>
<li>
Analyze the data obtained.

</li>
</ol>

<h4>Important Points</h4>


<p>
Three points to bear in mind when analyzing algorithm efficiency
empirically in the context of this exploration:
</p>
<ol>
<li>
You are <b>not</b> given specific algorithms to measure and compare,
just specific algorithm <b>types</b>.
</li>
<li>
You thus have great latitude in how to conduct and report on
your experiments, so use your cohort collaboration to the max.
</li>
<li>
You may study/use any code found in <a href="http://firstthreeodds.org/cs306/empirical.zip">http://firstthreeodds.org/cs306/empirical.zip</a>

</li>
</ol>

<h3>Requirements</h3>


<p>
Implement two "n-squared" sorting algorithms and two "n log n"
algorithms of your choice using any language you choose (mixing languages
if you choose, but see the questions below). Analyze the four algorithms
and show how you found the running times for each. Do an empirical
measurement of the running times on each of the four algorithms and
compare the results with the theoretical running time. When doing the
empirical measurements, you will probably need to loop over most
problem sizes several times so they produce measurable run times.
Make available all code and scripts you use to obtain the running times.
</p>
<p>
For maximum benefit, treat this as an open-ended project, and
explore some additional factors affecting runtime. For example,
answer these questions, and then some:
</p>
<ol>
<li>
How does the language (Java, C++, etc.),
including compiler switches, affect performance?
</li>
<li>
How does the data type (<b>int</b>, <b>float</b>, etc.) to be sorted
affect performance?
</li>
<li>
When does overhead from recursion affect performance?
</li>
<li>
How does the operating system affect the performance of the algorithms? 
</li>
<li>
How do the theoretical running time and the empirical running time
compare? If they are different, why are they different?
</li>
<li>
How does optimization of a compiler affect performance?
</li>
<li>
What are the pros and cons of each algorithm based on
the theoretical and the empirical analysis?
</li>
<li>
Are there situations where a slow algorithm is acceptable to use
in an application?
</li>
<li>
Are there situations where a fast algorithms might be the only option?

</li>
</ol>

<h3>Expectations</h3>


<ul>
<li>
Do work that you can take pride in reporting on.
</li>
<li>
Make your report look and feel professional --- which for starters
means to eradicate all mechanical infelicities.
</li>
<li>
Include an introduction (clearly stating the goal(s) of this
activity) and a conclusion (summarizing the analysis).
</li>
<li>
Mention the hardware, compiler, timers used, and any and all
assumptions made.
</li>
<li>
<b>Be specific</b> about what the best case,
average case, and worst case are for each algorithm.
</li>
<li>
Include a comparison of timings for each sort. It's acceptable
and desirable to plot your timings for multiple sorts on the same
graph, but also include a table of your timings.
</li>
<li>
Include a comparison of the two "n-squared" algorithms and a
comparison of the two "n log n" algorithms, but <b>NOT</b> a
comparison of an "n-squared" with an "n log n" algorithm, which
doesn't make sense.
</li>
</ul>
<p class="author"> Author: Rick Neff
<a href="mailto:NeffR@byui.edu">&lt;NeffR@byui.edu&gt;</a>
</p>
<p class="date"> Date: 2015/10/12 08:32:06</p>
</body>
</html>
